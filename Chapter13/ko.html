<!DOCTYPE html>
<html>
<head>
  <title>Shell Script</title>
</head>
<body>
<h1>셸 스크립트</h1>

<h3>스크립트란</h3>

<ul>
  <li>인터프리터라 불리는 다른 프로그램에 의해 실행되는 프로그램</li>
  <li>자바 스크립트, Perl, 파이썬,...</li>
</ul>

<h3>셸 스크립트란</h3>

<ul>
  <li>셸이 실행하는 프로그램</li>
  <li>유닉스 명령 + 셸이 제공하는 프로그램 구성 요소</li>
  <li>셸 스크립트 파일 이름은 키워드나 앨리어스, 내장 명령과 같은 이름을 쓰지 않는 것이 바람직함</li>
  <li>셸 명령 실행 순서: 앨리어스 → 키워드(if, while, until 등) → 함수 → 내장 명령(cd, echo 등) → 스크립트, 유틸리트 등 PATH 경로에 있는 실행 가능한 파일</li>
</ul>

<h3>셸 스크립트 만들기 예시</h3>

<ul>
  <li><code>#!/usr/bin/bash</code>: 배쉬로 실행하겠다는 의미 <code>#!(매직넘버로 파일 가장 처음 위치)</code></li>
  <li>여기서 쉘이 아니라 다른 실행 가능 명령어 줘도 됨. (<code>#!/usr/bin/more</code>)</li>
  <li><code>#</code>: 주석을 의미</li>
  <li>sh 로 실행하거나, chmod +x를 해줘서 직접 실행</li>
  <li>셸 스크립트 종료: <code>exit(n);</code> (종료 상태는 <code>$?</code> 변수에 저장)</li>
</ul>

<h2>셸 변수 사용하기</h2>

<p>변수: 프로그램에서 처리하는 다양한 정보를 저장하는 곳</p>

<p>종류: 셸 변수(현재 셸에서만 사용 가능), 환경변수(모든 셸에서 사용 가능)</p>

<p>지정 방법: 변수명 = 값</p>

<p>보는 방법: <code>${name}</code></p>

<h3>셸 변수 문자열 처리</h3>

<ul>
  <li><code>${PATH%/bin}</code>: 뒤에서부터 패턴과 일치하는 최소 부분을 제거한다. (뒤에서부터 찾아서 먼저 찾은 것만 삭제)</li>
  <li><code>${PATH%%/bin*</code>: %% 사용시 지정한 패턴이 중간에 있다면 임의의 값이 나올 수 있다는 표시로 *를 적어줘야 한다.</li>
  <li><code>${PATH2#/export}</code>: 앞에서부터 패턴과 일치하는 최소 부분을 제거 (##은 최대 부분이다.)</li>
  <li>##도 역시 <code>${PATH2##*/}</code>: 나올 수 있다는 패턴이 있다는 것에서 *을 붙혀준다.</li>
  <li><code>${#PATH}</code> 이렇게 하면 저장된 문자의 갯수가 출력된다!!</li>
</ul>

<h2>명령행 인자 처리</h2>

<h3>명령행 인자</h3>

<ul>
  <li>스크립트를 실행할 때 인자로 주어진 값</li>
</ul>

<h3>위치 매개 변수</h3>

<ul>
  <li>명령행 인자를 저장하는 스크립트 변수</li>
  <li>인자의 위치에 따라 이름이 정해짐</li>
  <li><code>$0</code>: 현재 스크립트의 이름</li>
  <li><code>$1 - $9</code>: 명령행에 주어진 1~9번 포지션 인자</li>
  <li><code>${10}</code>: 10 번째 포지션 인자.</li>
  <li><code>$#</code>: 전체 포지션 인자 갯수</li>
  <li><code>$*</code>: 모든 포지션 인자</li>
  <li><code>$@</code>: <code>$*</code> 과 동일하다.</li>
  <li><code>"$*"</code>: <code>$1,$2,$3</code> 을 하나로 묶어서 문자열로 취급한다.</li>
  <li><code>"$@"</code>: <code>$1,$2,$3</code> 의미하는데 각각 독립적인 문자열로 취급된다.</li>
  <li><code>$?</code>: 최근 실행된 명령의 종료 값</li>
  <li><code>set --</code>: 모든 포지션 인자들을 삭제하거나 설정을 해지함.</li>
</ul>

<h3>셸 변수 사용하기</h3>

<ul>
  <li>작은 따옴표: 모든 특수문자들이 해석되는 것을 막는다.</li>
  <li>큰 따옴표: 변수나 명령의 대체만 허용된다.</li>
  <li>역슬레시 (\): 단일 문자가 해석되는 것을 막음</li>
</ul>

<h3>명령 대체: 명령 실행 결과를 문자열로 반환</h3>

<ul>
  <li>백쿼터 <code>echo `date`</code>: 내부의 명령 실행 결과를 문자열로 반환한다.</li>
  <li><code>echo $(명령)</code>: 명령 대체됨</li>
</ul>

<h3>사용자로부터 입력 받기</h3>

<ul>
  <li><code>read</code>: 사용자로부터 직접 입력</li>
  <li>쉘 내장 명령으로 터미널이 파일로부터 입력을 처리한다.</li>
  <li><code>read x</code>: 표준 입력에서 한 행을 입력 받아 x에 저장한다.</li>
  <li><code>read first last</code>: 표준 입력에서 한 행을 입력 받아 첫번째 단어를 first에 저장하고 나머지를 last에 저장한다.</li>
  <li><code>read -p prompt</code>: prompt를 출력시키고 입력을 기다린다. 입력된 값은 REPLY변수에 저장된다. (prompt값은 안 들어감)</li>
  <li>여기서 저장을 받는다는 것은 전부 쉘 변수에 저장한다는 것을 의미한다.</li>
</ul>

<h3>here 문서를 통한 입력: &lt;&lt;</h3>

<ul>
  <li>표준 입력을 사용자로부터 직접 받아들이지 않고 자동 처리</li>
  <li><code>TERMINATOR</code>가 입력될 때까지 기술된 부분을 키보드 입력으로 처리</li>
  <li>키보드 입력의 종료 문자로 사용하는 EOF(^D) 문자를 파일 안에서 사용할 수 없기 때문에 입력 종료를 나타내는 문자열을 지정하여 사용</li>
  <li>키보드 입력의 종료 문자로 사용하는 EOF(^D) 문자를 파일 안에서 사용할 수 없기 때문에 입력 종료를 나타내는 문자열을 지정하여 사용</li>
</ul>

<h2>연산자</h2>

<ul>
  <li>프로그램에서 자료를 처리하는 방법</li>
  <li>산술 연산자, 비교 연산자, 논리 연산자, 비트 연산자 제공</li>
  <li>수치 연산자 사용시 let 또는 (( )) 사용해야 함</li>
  <li><code>let a=20</code>: 공백 사용 불가 (사용하려면 <code>let "a = 20"</code>)</li>
  <li>괄호 안에서는 공백 사용 가능 <code>(( a = 30 ))</code></li>
</ul>

<h2>제어문</h2>

<ul>
  <li>프로그램 내의 문장 실행 순서를 제어하는 것</li>
</ul>

<h3>선택적 실행문</h3>

<ul>
  <li>프로그램 실행문을 조건에 따라 선택적으로 실행</li>
  <li>If, select</li>
</ul>

<h3>선택적 실행문 case</h3>

<ul>
  <li>주어진 변수의 값에 따라 실행할 명령 따로 지정</li>
  <li>변수와 각 조건식을 ;; 으로 구분 (일반적으로 case문에서 사용됨)</li>
  <li>default를 만들고 싶다면 *) 를 사용한다.</li>
  <li>조건식으로 <code>[조건]</code> 을 사용하며 <code>==</code> 로 같다고 맞춰주고 비교값은 따옴표를 써주는 것이 좋다.</li>
  <li>왜냐하면 숫자로 비교해야할 때 다른 명령과 달리 "" 가 없어야하기 때문이다.</li>
</ul>

<h3>반복 실행문</h3>

<ul>
  <li>동일한 명령을 여러번 실행</li>
  <li>for, while, until</li>
</ul>

<h3>반복 실행문 for</h3>

<ul>
  <li>특정 범위나 목록에서 값을 하나씩 가져와 명령 실행</li>
  <li>for문의 변수는 매번 새로운 값을 받으므로, 루프 안에서 지역 변수로 취급됨</li>
  <li>변수 설정 형태에는 세 가지 방법 사용 가능
    <ul>
      <li><code>for i in 1 2 3 4 5</code>: 명시적으로 값을 나열</li>
      <li><code>for i in {1..5}</code>: 범위 표시</li>
      <li><code>for i in $(seq 1 5)</code>: seq 명령의 결과 사용</li>
    </ul>
  </li>
  <li><code>for i in *</code>: 현재 디렉토리의 모든 파일</li>
  <li><code>for i in /usr/*</code>: /usr 디렉토리의 모든 파일</li>
</ul>

<h3>반복 실행문 while</h3>

<ul>
  <li>조건이 참일 때까지 반복적으로 명령을 실행</li>
  <li>while [ 조건 ]; do 명령어; done</li>
</ul>

<h3>반복 실행문 until</h3>

<ul>
  <li>조건이 거짓일 때까지 반복적으로 명령을 실행</li>
  <li>until [ 조건 ]; do 명령어; done</li>
</ul>

<h2>함수</h2>

<ul>
  <li>하나의 프로그램 단위로 작성된 코드 묶음</li>
  <li>코드의 재사용과 구조화를 위해 사용</li>
  <li>함수 정의와 호출</li>
  <li>함수 정의: <code>function name { commands }</code> 또는 <code>name() { commands }</code></li>
  <li>함수 호출: <code>name arguments</code></li>
  <li>반환값: 함수가 실행된 후 결과값을 반환</li>
  <li>반환값을 사용하기 위해서는 명령 대체나 변수에 저장해야 함</li>
</ul>
<h1>디버깅</h1>
<h3>스크립트 실행 도중 발생한 오류 수정 방법</h3>
<ul>
  <li>구문 오류: 셸이 실행 도중 구문 오류가 발생한 라인 번호를 출력</li>
  <li>실행 오류: 오류 메시지 없이 실행이 안 되거나 비정상 종료</li>
</ul>
<h3>오류 수정 방법</h3>
<ul>
  <li><code>bash -x</code>: 가장 간단한 스크립트 실행 오류 수정 방법으로, 스크립트의 각 행이 실행될 때마다 화면에 출력됩니다.</li>
  <li><code>trap</code>: <code>trap</code> 명령을 사용하여 시그널을 지정하면 해당 시그널이 스크립트로 전달될 때마다 지정한 명령이 실행됩니다. 스크립트의 명령이 한 줄씩 실행될 때마다 <code>DEBUG</code> 시그널이 스크립트로 전달되며, 이를 활용하여 원하는 변수값을 출력하여 스크립트가 실행되는 도중 변수값을 확인할 수 있습니다.</li>
</ul>
</body>
</html>
